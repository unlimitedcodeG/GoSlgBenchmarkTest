// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: session_messages.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSessionMessages = `-- name: CountSessionMessages :one
SELECT COUNT(*) FROM session_messages WHERE session_id = $1
`

func (q *Queries) CountSessionMessages(ctx context.Context, sessionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countSessionMessages, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSessionMessage = `-- name: CreateSessionMessage :one
INSERT INTO session_messages (
    session_id, direction, opcode, message_size, body_size, 
    sequence_num, message_hash, raw_data, timestamp
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, session_id, direction, opcode, message_size, body_size, sequence_num, message_hash, raw_data, timestamp, created_at
`

type CreateSessionMessageParams struct {
	SessionID   int64              `json:"session_id"`
	Direction   string             `json:"direction"`
	Opcode      pgtype.Int4        `json:"opcode"`
	MessageSize pgtype.Int4        `json:"message_size"`
	BodySize    pgtype.Int4        `json:"body_size"`
	SequenceNum pgtype.Int8        `json:"sequence_num"`
	MessageHash pgtype.Text        `json:"message_hash"`
	RawData     []byte             `json:"raw_data"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
}

func (q *Queries) CreateSessionMessage(ctx context.Context, arg CreateSessionMessageParams) (SessionMessage, error) {
	row := q.db.QueryRow(ctx, createSessionMessage,
		arg.SessionID,
		arg.Direction,
		arg.Opcode,
		arg.MessageSize,
		arg.BodySize,
		arg.SequenceNum,
		arg.MessageHash,
		arg.RawData,
		arg.Timestamp,
	)
	var i SessionMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Direction,
		&i.Opcode,
		&i.MessageSize,
		&i.BodySize,
		&i.SequenceNum,
		&i.MessageHash,
		&i.RawData,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionMessages = `-- name: GetSessionMessages :many
SELECT id, session_id, direction, opcode, message_size, body_size, sequence_num, message_hash, raw_data, timestamp, created_at FROM session_messages 
WHERE session_id = $1 
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type GetSessionMessagesParams struct {
	SessionID int64 `json:"session_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetSessionMessages(ctx context.Context, arg GetSessionMessagesParams) ([]SessionMessage, error) {
	rows, err := q.db.Query(ctx, getSessionMessages, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionMessage{}
	for rows.Next() {
		var i SessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Direction,
			&i.Opcode,
			&i.MessageSize,
			&i.BodySize,
			&i.SequenceNum,
			&i.MessageHash,
			&i.RawData,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionMessagesByDirection = `-- name: GetSessionMessagesByDirection :many
SELECT id, session_id, direction, opcode, message_size, body_size, sequence_num, message_hash, raw_data, timestamp, created_at FROM session_messages 
WHERE session_id = $1 AND direction = $2
ORDER BY timestamp DESC
`

type GetSessionMessagesByDirectionParams struct {
	SessionID int64  `json:"session_id"`
	Direction string `json:"direction"`
}

func (q *Queries) GetSessionMessagesByDirection(ctx context.Context, arg GetSessionMessagesByDirectionParams) ([]SessionMessage, error) {
	rows, err := q.db.Query(ctx, getSessionMessagesByDirection, arg.SessionID, arg.Direction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionMessage{}
	for rows.Next() {
		var i SessionMessage
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Direction,
			&i.Opcode,
			&i.MessageSize,
			&i.BodySize,
			&i.SequenceNum,
			&i.MessageHash,
			&i.RawData,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
