// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: slg_battles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSLGBattle = `-- name: CreateSLGBattle :one
INSERT INTO slg_battle_records (
    test_id, battle_id, battle_type, player_ids, map_id, battle_data, start_time
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, test_id, battle_id, battle_type, player_ids, map_id, winner, battle_duration, init_latency, update_frequency, sync_error_rate, unity_fps, battle_data, start_time, end_time, created_at, updated_at
`

type CreateSLGBattleParams struct {
	TestID     int64              `json:"test_id"`
	BattleID   string             `json:"battle_id"`
	BattleType pgtype.Text        `json:"battle_type"`
	PlayerIds  []byte             `json:"player_ids"`
	MapID      pgtype.Text        `json:"map_id"`
	BattleData []byte             `json:"battle_data"`
	StartTime  pgtype.Timestamptz `json:"start_time"`
}

func (q *Queries) CreateSLGBattle(ctx context.Context, arg CreateSLGBattleParams) (SlgBattleRecord, error) {
	row := q.db.QueryRow(ctx, createSLGBattle,
		arg.TestID,
		arg.BattleID,
		arg.BattleType,
		arg.PlayerIds,
		arg.MapID,
		arg.BattleData,
		arg.StartTime,
	)
	var i SlgBattleRecord
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.BattleID,
		&i.BattleType,
		&i.PlayerIds,
		&i.MapID,
		&i.Winner,
		&i.BattleDuration,
		&i.InitLatency,
		&i.UpdateFrequency,
		&i.SyncErrorRate,
		&i.UnityFps,
		&i.BattleData,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSLGBattle = `-- name: GetSLGBattle :one
SELECT id, test_id, battle_id, battle_type, player_ids, map_id, winner, battle_duration, init_latency, update_frequency, sync_error_rate, unity_fps, battle_data, start_time, end_time, created_at, updated_at FROM slg_battle_records WHERE battle_id = $1
`

func (q *Queries) GetSLGBattle(ctx context.Context, battleID string) (SlgBattleRecord, error) {
	row := q.db.QueryRow(ctx, getSLGBattle, battleID)
	var i SlgBattleRecord
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.BattleID,
		&i.BattleType,
		&i.PlayerIds,
		&i.MapID,
		&i.Winner,
		&i.BattleDuration,
		&i.InitLatency,
		&i.UpdateFrequency,
		&i.SyncErrorRate,
		&i.UnityFps,
		&i.BattleData,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSLGBattleStats = `-- name: GetSLGBattleStats :one
SELECT 
    COUNT(*) as total_battles,
    COUNT(CASE WHEN end_time IS NOT NULL THEN 1 END) as completed_battles,
    AVG(battle_duration) as avg_duration,
    AVG(init_latency) as avg_init_latency,
    AVG(unity_fps) as avg_fps
FROM slg_battle_records WHERE test_id = $1
`

type GetSLGBattleStatsRow struct {
	TotalBattles     int64   `json:"total_battles"`
	CompletedBattles int64   `json:"completed_battles"`
	AvgDuration      float64 `json:"avg_duration"`
	AvgInitLatency   float64 `json:"avg_init_latency"`
	AvgFps           float64 `json:"avg_fps"`
}

func (q *Queries) GetSLGBattleStats(ctx context.Context, testID int64) (GetSLGBattleStatsRow, error) {
	row := q.db.QueryRow(ctx, getSLGBattleStats, testID)
	var i GetSLGBattleStatsRow
	err := row.Scan(
		&i.TotalBattles,
		&i.CompletedBattles,
		&i.AvgDuration,
		&i.AvgInitLatency,
		&i.AvgFps,
	)
	return i, err
}

const getSLGBattles = `-- name: GetSLGBattles :many
SELECT id, test_id, battle_id, battle_type, player_ids, map_id, winner, battle_duration, init_latency, update_frequency, sync_error_rate, unity_fps, battle_data, start_time, end_time, created_at, updated_at FROM slg_battle_records WHERE test_id = $1 ORDER BY start_time DESC
`

func (q *Queries) GetSLGBattles(ctx context.Context, testID int64) ([]SlgBattleRecord, error) {
	rows, err := q.db.Query(ctx, getSLGBattles, testID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SlgBattleRecord{}
	for rows.Next() {
		var i SlgBattleRecord
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.BattleID,
			&i.BattleType,
			&i.PlayerIds,
			&i.MapID,
			&i.Winner,
			&i.BattleDuration,
			&i.InitLatency,
			&i.UpdateFrequency,
			&i.SyncErrorRate,
			&i.UnityFps,
			&i.BattleData,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSLGBattle = `-- name: UpdateSLGBattle :one
UPDATE slg_battle_records 
SET winner = $2, battle_duration = $3, init_latency = $4, 
    update_frequency = $5, sync_error_rate = $6, unity_fps = $7,
    battle_data = $8, end_time = $9, updated_at = NOW()
WHERE id = $1
RETURNING id, test_id, battle_id, battle_type, player_ids, map_id, winner, battle_duration, init_latency, update_frequency, sync_error_rate, unity_fps, battle_data, start_time, end_time, created_at, updated_at
`

type UpdateSLGBattleParams struct {
	ID              int64              `json:"id"`
	Winner          pgtype.Text        `json:"winner"`
	BattleDuration  pgtype.Int8        `json:"battle_duration"`
	InitLatency     pgtype.Int8        `json:"init_latency"`
	UpdateFrequency pgtype.Numeric     `json:"update_frequency"`
	SyncErrorRate   pgtype.Numeric     `json:"sync_error_rate"`
	UnityFps        pgtype.Numeric     `json:"unity_fps"`
	BattleData      []byte             `json:"battle_data"`
	EndTime         pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) UpdateSLGBattle(ctx context.Context, arg UpdateSLGBattleParams) (SlgBattleRecord, error) {
	row := q.db.QueryRow(ctx, updateSLGBattle,
		arg.ID,
		arg.Winner,
		arg.BattleDuration,
		arg.InitLatency,
		arg.UpdateFrequency,
		arg.SyncErrorRate,
		arg.UnityFps,
		arg.BattleData,
		arg.EndTime,
	)
	var i SlgBattleRecord
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.BattleID,
		&i.BattleType,
		&i.PlayerIds,
		&i.MapID,
		&i.Winner,
		&i.BattleDuration,
		&i.InitLatency,
		&i.UpdateFrequency,
		&i.SyncErrorRate,
		&i.UnityFps,
		&i.BattleData,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
