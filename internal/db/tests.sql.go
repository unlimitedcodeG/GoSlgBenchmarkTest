// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTests = `-- name: CountTests :one
SELECT COUNT(*) FROM tests 
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR type = $1)
  AND ($2::text IS NULL OR status = $2)
  AND ($3::text IS NULL OR name ILIKE '%' || $3 || '%')
`

type CountTestsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
}

func (q *Queries) CountTests(ctx context.Context, arg CountTestsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTests, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTest = `-- name: CreateTest :one
INSERT INTO tests (
    name, type, status, config
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, type, status, start_time, end_time, duration, score, grade, config, error_message, created_at, updated_at, deleted_at
`

type CreateTestParams struct {
	Name   string      `json:"name"`
	Type   string      `json:"type"`
	Status string      `json:"status"`
	Config pgtype.Text `json:"config"`
}

func (q *Queries) CreateTest(ctx context.Context, arg CreateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.Name,
		arg.Type,
		arg.Status,
		arg.Config,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Status,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Score,
		&i.Grade,
		&i.Config,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTest = `-- name: DeleteTest :exec
UPDATE tests SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteTest(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTest, id)
	return err
}

const getTest = `-- name: GetTest :one
SELECT id, name, type, status, start_time, end_time, duration, score, grade, config, error_message, created_at, updated_at, deleted_at FROM tests WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTest(ctx context.Context, id int64) (Test, error) {
	row := q.db.QueryRow(ctx, getTest, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Status,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Score,
		&i.Grade,
		&i.Config,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTestList = `-- name: GetTestList :many
SELECT id, name, type, status, start_time, end_time, duration, score, grade, config, error_message, created_at, updated_at, deleted_at FROM tests 
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR type = $1)
  AND ($2::text IS NULL OR status = $2)
  AND ($3::text IS NULL OR name ILIKE '%' || $3 || '%')
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetTestListParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetTestList(ctx context.Context, arg GetTestListParams) ([]Test, error) {
	rows, err := q.db.Query(ctx, getTestList,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Status,
			&i.StartTime,
			&i.EndTime,
			&i.Duration,
			&i.Score,
			&i.Grade,
			&i.Config,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestStats = `-- name: GetTestStats :one
SELECT 
    COUNT(*) as total_tests,
    COUNT(CASE WHEN status = 'running' THEN 1 END) as running_tests,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_tests,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_tests
FROM tests WHERE deleted_at IS NULL
`

type GetTestStatsRow struct {
	TotalTests     int64 `json:"total_tests"`
	RunningTests   int64 `json:"running_tests"`
	CompletedTests int64 `json:"completed_tests"`
	FailedTests    int64 `json:"failed_tests"`
}

func (q *Queries) GetTestStats(ctx context.Context) (GetTestStatsRow, error) {
	row := q.db.QueryRow(ctx, getTestStats)
	var i GetTestStatsRow
	err := row.Scan(
		&i.TotalTests,
		&i.RunningTests,
		&i.CompletedTests,
		&i.FailedTests,
	)
	return i, err
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests 
SET status = $2, start_time = $3, end_time = $4, duration = $5, 
    score = $6, grade = $7, error_message = $8, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, type, status, start_time, end_time, duration, score, grade, config, error_message, created_at, updated_at, deleted_at
`

type UpdateTestParams struct {
	ID           int64              `json:"id"`
	Status       string             `json:"status"`
	StartTime    pgtype.Timestamptz `json:"start_time"`
	EndTime      pgtype.Timestamptz `json:"end_time"`
	Duration     pgtype.Int8        `json:"duration"`
	Score        pgtype.Numeric     `json:"score"`
	Grade        pgtype.Text        `json:"grade"`
	ErrorMessage pgtype.Text        `json:"error_message"`
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, updateTest,
		arg.ID,
		arg.Status,
		arg.StartTime,
		arg.EndTime,
		arg.Duration,
		arg.Score,
		arg.Grade,
		arg.ErrorMessage,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Status,
		&i.StartTime,
		&i.EndTime,
		&i.Duration,
		&i.Score,
		&i.Grade,
		&i.Config,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
